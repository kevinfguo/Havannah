'use strict';
var EventEmitter = require('events').EventEmitter;
<<<<<<< HEAD
var sysPath = require('path');
var each = require('async-each');

var NodeFsHandler = require('./nodefs-handler');
var FsEventsHandler = require('./fsevents-handler');
exports.isBinaryPath = require('./is-binary');

var platform = require('os').platform();
=======
var fs = require('fs');
var sysPath = require('path');
var each = require('async-each');
var anymatch = require('anymatch');
var globparent = require('glob-parent');

var NodeFsHandler = require('./nodefs-handler');
var FsEventsHandler = require('./fsevents-handler');
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1

// Public: Main class.
// Watches files & directories for changes.
//
// * _opts - object, chokidar options hash
//
// Emitted events:
// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
//
// Examples
//
//  var watcher = new FSWatcher()
//    .add(directories)
//    .on('add', function(path) {console.log('File', path, 'was added');})
//    .on('change', function(path) {console.log('File', path, 'was changed');})
//    .on('unlink', function(path) {console.log('File', path, 'was removed');})
//    .on('all', function(event, path) {console.log(path, ' emitted ', event);})
//
function FSWatcher(_opts) {
  var opts = {};
  // in case _opts that is passed in is a frozen object
  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
  this._watched = Object.create(null);
<<<<<<< HEAD
  this._watchers = [];
  this._ignoredPaths = Object.create(null);
=======
  this._closers = Object.create(null);
  this._ignoredPaths = Object.create(null);
  Object.defineProperty(this, '_globIgnored', {
    get: function() { return Object.keys(this._ignoredPaths); }
  });
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  this.closed = false;
  this._throttled = Object.create(null);
  this._symlinkPaths = Object.create(null);

  function undef(key) {
    return opts[key] === undefined;
  }

  // Set up default options.
  if (undef('persistent')) opts.persistent = true;
  if (undef('ignoreInitial')) opts.ignoreInitial = false;
  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef('interval')) opts.interval = 100;
  if (undef('binaryInterval')) opts.binaryInterval = 300;
  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs.watch.
  if (undef('usePolling') && !opts.useFsEvents) {
<<<<<<< HEAD
    opts.usePolling = platform === 'darwin';
=======
    opts.usePolling = process.platform === 'darwin';
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = Object.create(null);

  if (undef('followSymlinks')) opts.followSymlinks = true;

<<<<<<< HEAD
  this._isntIgnored = function(entry) {
    return !this._isIgnored(entry.path, entry.stat);
=======
  this._isntIgnored = function(path, stat) {
    return !this._isIgnored(path, stat);
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  }.bind(this);

  var readyCalls = 0;
  this._emitReady = function() {
    if (++readyCalls >= this._readyCount) {
      this._emitReady = Function.prototype;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(this.emit.bind(this, 'ready'));
    }
  }.bind(this);

  this.options = opts;

  // You’re frozen when your heart’s not open.
  Object.freeze(opts);
}

FSWatcher.prototype = Object.create(EventEmitter.prototype);

// Common helpers
// --------------
<<<<<<< HEAD
FSWatcher.prototype._emit = function(event, target, val1, val2, val3) {
  var args = [event, target, val1, val2, val3];
  if (this.options.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks[target] = args;
=======

// Private method: Normalize and emit events
//
// * event     - string, type of event
// * path      - string, file or directory path
// * val[1..3] - arguments to be passed with event
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
  var args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);
  if (this.options.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks[path] = args;
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
      setTimeout(function() {
        Object.keys(this._pendingUnlinks).forEach(function(path) {
          this.emit.apply(this, this._pendingUnlinks[path]);
          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
          delete this._pendingUnlinks[path];
        }.bind(this));
      }.bind(this), 100);
      return this;
<<<<<<< HEAD
    } else if (event === 'add' && this._pendingUnlinks[target]) {
      event = args[0] = 'change';
      delete this._pendingUnlinks[target];
    }
    if (event === 'change') {
      if (!this._throttle('change', target, 50)) return this;
    }
  }
  this.emit.apply(this, args);
  if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
  return this;
};

FSWatcher.prototype._handleError = function(error) {
  if (error &&
    error.code !== 'ENOENT' &&
    error.code !== 'ENOTDIR' &&
    !(error.code === 'EPERM' && !this.options.ignorePermissionErrors)
=======
    } else if (event === 'add' && this._pendingUnlinks[path]) {
      event = args[0] = 'change';
      delete this._pendingUnlinks[path];
    }
    if (event === 'change') {
      if (!this._throttle('change', path, 50)) return this;
    }
  }

  var emitEvent = function() {
    this.emit.apply(this, args);
    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
  }.bind(this);

  if (
    this.options.alwaysStat && val1 === undefined &&
    (event === 'add' || event === 'addDir' || event === 'change')
  ) {
    fs.stat(path, function(error, stats) {
      args.push(stats);
      emitEvent();
    });
  } else {
    emitEvent();
  }

  return this;
};

// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error && error.code;
  if (error &&
    code !== 'ENOENT' &&
    code !== 'ENOTDIR' &&
    !(code === 'EPERM' && !this.options.ignorePermissionErrors)
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  ) this.emit('error', error);
  return error || this.closed;
};

<<<<<<< HEAD
=======
// Private method: Helper utility for throttling
//
// * action  - string, type of action being throttled
// * path    - string, path being acted upon
// * timeout - int, duration of time to suppress duplicate actions
//
// Returns throttle tracking object or false if action should be suppressed
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
FSWatcher.prototype._throttle = function(action, path, timeout) {
  if (!(action in this._throttled)) {
    this._throttled[action] = Object.create(null);
  }
  var throttled = this._throttled[action];
  if (path in throttled) return false;
  function clear() {
    delete throttled[path];
    clearTimeout(timeoutObject);
  }
  var timeoutObject = setTimeout(clear, timeout);
  throttled[path] = {timeoutObject: timeoutObject, clear: clear};
  return throttled[path];
};

<<<<<<< HEAD
FSWatcher.prototype._isIgnored = function(path, stats) {
  if (
    this.options.atomic &&
    /^\..*\.(sw[px])$|\~$|\.subl.*\.tmp/.test(path)
  ) return true;
  var userIgnored = (function(ignored) {
    switch (toString.call(ignored)) {
    case '[object RegExp]':
      return function(string) {
        return ignored.test(string);
      };
    case '[object Function]':
      return ignored;
    default:
      return function() {
        return false;
      };
    }
  })(this.options.ignored);
  var ignoredPaths = Object.keys(this._ignoredPaths);
  function isParent(ip) {
    return !path.indexOf(ip + sysPath.sep);
  }
  return ignoredPaths.length && ignoredPaths.some(isParent) ||
    userIgnored(path, stats);
};

// Directory helpers
// -----------------
=======
// Private method: Determines whether user has asked to ignore this path
//
// * path  - string, path to file or directory
// * stats - object, result of fs.stat
//
// Returns boolean
FSWatcher.prototype._isIgnored = function(path, stats) {
  if (
    this.options.atomic &&
    /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/.test(path)
  ) return true;
  var userIgnored = anymatch(this._globIgnored.concat(this.options.ignored));
  return userIgnored([path, stats]);
};

// Private method: Provides a set of common helpers and properties relating to
// symlink and glob handling
//
// * path - string, file, directory, or glob pattern being watched
//
// Returns object containing helpers for this path
FSWatcher.prototype._getWatchHelpers = function(path) {
  path = path.replace(/^\.[\/\\]/, '');
  var watchPath = globparent(path);
  var hasGlob = watchPath !== path;
  var globFilter = hasGlob ? anymatch(path) : false;

  var entryPath = function(entry) {
    return sysPath.join(watchPath, sysPath.relative(watchPath, entry.fullPath));
  }

  var filterPath = function(entry) {
    return (!hasGlob || globFilter(entryPath(entry))) &&
      this._isntIgnored(entryPath(entry), entry.stat);
  }.bind(this);

  var getDirParts = function(path) {
    if (!hasGlob) return false;
    var parts = sysPath.relative(watchPath, path).split(/[\/\\]/);
    return parts;
  }
  var dirParts = getDirParts(path);
  if (dirParts && dirParts.length > 1) dirParts.pop();

  var filterDir = function(entry) {
    if (hasGlob) {
      var entryParts = getDirParts(entry.fullPath);
      var unmatchedGlob = !dirParts.every(function(part, i) {
        return !entryParts[i] || anymatch(part, entryParts[i]);
      });
    }

    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
  }.bind(this);

  return {
    followSymlinks: this.options.followSymlinks,
    statMethod: this.options.followSymlinks ? 'stat' : 'lstat',
    path: path,
    watchPath: watchPath,
    entryPath: entryPath,
    hasGlob: hasGlob,
    globFilter: globFilter,
    filterPath: filterPath,
    filterDir: filterDir
  };
}

// Directory helpers
// -----------------

// Private method: Provides directory tracking objects
//
// * directory - string, path of the directory
//
// Returns the directory's tracking object
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
FSWatcher.prototype._getWatchedDir = function(directory) {
  var dir = sysPath.resolve(directory);
  if (!(dir in this._watched)) this._watched[dir] = {
    _items: Object.create(null),
    add: function(item) {this._items[item] = true;},
    remove: function(item) {delete this._items[item];},
    has: function(item) {return item in this._items;},
    children: function() {return Object.keys(this._items);}
  };
  return this._watched[dir];
};

// File helpers
// ------------

<<<<<<< HEAD
// Private: Check for read permissions
=======
// Private method: Check for read permissions
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
//
// * stats - object, result of fs.stat
//
<<<<<<< HEAD
// Returns Boolean
=======
// Returns boolean
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
FSWatcher.prototype._hasReadPermissions = function(stats) {
  return Boolean(4 & parseInt((stats.mode & 0x1ff).toString(8)[0], 10));
};

<<<<<<< HEAD
// Private: Handles emitting unlink events for
=======
// Private method: Handles emitting unlink events for
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
// files and directories, and via recursion, for
// files and directories within directories that are unlinked
//
// * directory - string, directory within which the following item is located
// * item      - string, base path of item/directory
//
<<<<<<< HEAD
// Returns nothing.
=======
// Returns nothing
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
FSWatcher.prototype._remove = function(directory, item) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
<<<<<<< HEAD
  var fullPath = sysPath.join(directory, item);
  var absolutePath = sysPath.resolve(fullPath);
  var isDirectory = this._watched[fullPath] || this._watched[absolutePath];

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', fullPath, 100)) return;
=======
  var path = sysPath.join(directory, item);
  var fullPath = sysPath.resolve(path);
  var isDirectory = this._watched[path] || this._watched[fullPath];

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1

  // if the only watched file is removed, watch for its return
  var watchedDirs = Object.keys(this._watched);
  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
<<<<<<< HEAD
    this.add(directory, item);
=======
    this.add(directory, item, true);
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
<<<<<<< HEAD
  var nestedDirectoryChildren = this._getWatchedDir(fullPath).children();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(function(nestedItem) {
    this._remove(fullPath, nestedItem);
=======
  var nestedDirectoryChildren = this._getWatchedDir(path).children();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(function(nestedItem) {
    this._remove(path, nestedItem);
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  }, this);

  // Remove directory / file from watched list.
  this._getWatchedDir(directory).remove(item);

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
<<<<<<< HEAD
  delete this._watched[fullPath];
  delete this._watched[absolutePath];
  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
  this._emit(eventName, fullPath);
};

// Public: Adds directories / files for tracking.

// * files    - array of strings (file or directory paths).
// * _origAdd - private argument for handling non-existent paths to be watched

// Returns an instance of FSWatcher for chaining.
FSWatcher.prototype.add = function(files, _origAdd) {
  this.closed = false;
  if (!('_initialAdd' in this)) this._initialAdd = true;
  if (!Array.isArray(files)) files = [files];

  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
    if (!this._readyCount) this._readyCount = files.length;
    if (this.options.persistent) this._readyCount *= 2;
    files.forEach(this._addToFsEvents, this);
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += files.length;
    each(files, function(file, next) {
      this._addToNodeFs(file, this._initialAdd, _origAdd, function(err, res) {
=======
  delete this._watched[path];
  delete this._watched[fullPath];
  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
  if (!this._isIgnored(path)) this._emit(eventName, path);
};

// Public method: Adds paths to be watched on an existing FSWatcher instance

// * paths     - string or array of strings, file/directory paths and/or globs
// * _origAdd  - private boolean, for handling non-existent paths to be watched
// * _internal - private boolean, indicates a non-user add

// Returns an instance of FSWatcher for chaining.
FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
  this.closed = false;
  if (!Array.isArray(paths)) paths = [paths];

  if (this.options.cwd) paths = paths.map(function(path) {
    return sysPath.join(this.options.cwd, path);
  }, this);

  // set aside negated glob strings
  paths = paths.filter(function(path) {
    if (path[0] === '!') this._ignoredPaths[path.substring(1)] = true;
    else {
      // if a path is being added that was previously ignored, stop ignoring it
      delete this._ignoredPaths[path];
      delete this._ignoredPaths[path + '/**/*'];

      return true;
    }
  }, this);

  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach(this._addToFsEvents, this);
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    each(paths, function(path, next) {
      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
        if (res) this._emitReady();
        next(err, res);
      }.bind(this));
    }.bind(this), function(error, results) {
      results.forEach(function(item){
        if (!item) return;
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      }, this);
    }.bind(this));
  }

<<<<<<< HEAD
  this._initialAdd = false;
  return this;
};

// Public: Remove all listeners from watched files.

// Returns an instance of FSWatcher for chaining.
=======
  return this;
};

// Public method: Close watchers or start ignoring events from specified paths.

// * paths     - string or array of strings, file/directory paths and/or globs

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.unwatch = function(paths) {
  if (this.closed) return this;
  if (!Array.isArray(paths)) paths = [paths];

  paths.forEach(function(path) {
    if (this._closers[path]) {
      this._closers[path]();
    } else {
      this._ignoredPaths[path] = true;
      if (path in this._watched) this._ignoredPaths[path + '/**/*'] = true;
    }
  }, this);

  return this;
};

// Public method: Close watchers and remove all listeners from watched paths.

// Returns instance of FSWatcher for chaining.
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
FSWatcher.prototype.close = function() {
  if (this.closed) return this;

  this.closed = true;
<<<<<<< HEAD
  this._watchers.forEach(function(watcher) {
    watcher.close();
  });
=======
  Object.keys(this._closers).forEach(function(watchPath) {
    this._closers[watchPath]();
    delete this._closers[watchPath];
  }, this);
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
  this._watched = Object.create(null);

  this.removeAllListeners();
  return this;
};

// Attach watch handler prototype methods
<<<<<<< HEAD
function importProto (proto) {
  Object.keys(proto).forEach(function(method) {
    FSWatcher.prototype[method] = proto[method];
  });
}
importProto(NodeFsHandler.prototype);
if (FsEventsHandler.canUse()) importProto(FsEventsHandler.prototype);

exports.FSWatcher = FSWatcher;

exports.watch = function(files, options) {
  return new FSWatcher(options).add(files);
=======
function importHandler(handler) {
  Object.keys(handler.prototype).forEach(function(method) {
    FSWatcher.prototype[method] = handler.prototype[method];
  });
}
importHandler(NodeFsHandler);
if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

// Public function: Instantiates watcher with paths to be tracked.

// * paths     - string or array of strings, file/directory paths and/or globs
// * options   - object, chokidar options

// Returns an instance of FSWatcher for chaining.
exports.watch = function(paths, options) {
  return new FSWatcher(options).add(paths);
>>>>>>> b832e7896dc8e327d5d27ca12880454a513dbcc1
};
